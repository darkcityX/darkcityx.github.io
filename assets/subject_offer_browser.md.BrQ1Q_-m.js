import{_ as a,c as i,a0 as n,o as e}from"./chunks/framework.CSihnngI.js";const c=JSON.parse('{"title":"浏览器相关面试题汇总","description":"","frontmatter":{},"headers":[],"relativePath":"subject/offer/browser.md","filePath":"subject/offer/browser.md","lastUpdated":1750953333000}'),l={name:"subject/offer/browser.md"};function p(t,s,h,r,k,E){return e(),i("div",null,s[0]||(s[0]=[n(`<h1 id="浏览器相关面试题汇总" tabindex="-1">浏览器相关面试题汇总 <a class="header-anchor" href="#浏览器相关面试题汇总" aria-label="Permalink to &quot;浏览器相关面试题汇总&quot;">​</a></h1><h2 id="什么是异步函数" tabindex="-1">什么是异步函数 <a class="header-anchor" href="#什么是异步函数" aria-label="Permalink to &quot;什么是异步函数&quot;">​</a></h2><p>js 是单线程语言，同一时间只能处理一个任务。如果请求得是后端，这个响应可能几秒之后才会响应，所以要先跳过这个任务，继续向下执行。这种等待主进程结束再执行的函数任务被称为异步函数。常见的异步函数有 <code>async/await</code>、<code>promise</code>、<code>定时器</code></p><h2 id="什么是事件循环" tabindex="-1">什么是事件循环 <a class="header-anchor" href="#什么是事件循环" aria-label="Permalink to &quot;什么是事件循环&quot;">​</a></h2><div class="danger custom-block"><p class="custom-block-title">废弃解释</p><p>因为 js 是单线程语言，他就好比一个人再工作，但是同一时间只能做一项工作任务，所以就产生了任务队列，需要将接下来的工作都放在任务队列里面编排，干完一项任务之后再进行下一项任务。</p><p>但是任务队列还会分成三种：<code>主任务队列、微任务队列、宏任务队列</code>，每种不同的任务类型会放在不同的任务队列中，同步代码从上到下，都会放在<code>主任务队列</code>中；异步函数，如<code>seTimeout</code>、<code>setInterval</code>，属于异步任务，会放在<code>宏任务队列</code>；那么<code>微任务</code>呢，指的就是 Promise 通过.then()的回调。</p><p>任务的优先级为： <code>主任务队列 &gt; 微任务队列 &gt; 宏任务队列</code></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 宏任务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;setTimeout&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 主进程</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Promise&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;成功了&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 微任务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></div><p>事件循环也叫消息循环，是浏览器主线程的工作方式。</p><p>在 chorme 源码中，主线程会开启一个不会停止的 for 循环，每次循环，都会从消息队列中取出第一个任务执行，而其他线程则会在合适的时候将任务放在消息队列的末尾。</p><p>过去把消息队列简单的划分为宏任务和微任务，目前已无法满足浏览器复杂的环境，取而代之的是一种更加灵活的处理方式。</p><p>根据 W3C 的解释，每个任务都有自己的任务类型，同类型的任务都在同一个队列中，不同的队列有不同的优先级，在一次事件循环中，由浏览器决定取哪一个队列的任务。但浏览器必须有一个微任务队列，微任务队列的任务一定具有最高的优先级，必须优先调度执行。</p>`,9)]))}const o=a(l,[["render",p]]);export{c as __pageData,o as default};
