import{_ as t,c as i,a0 as a,o}from"./chunks/framework.CSihnngI.js";const h=JSON.parse('{"title":"javascript 面试题汇总","description":"","frontmatter":{},"headers":[],"relativePath":"subject/offer/javascript.md","filePath":"subject/offer/javascript.md","lastUpdated":1753616840000}'),r={name:"subject/offer/javascript.md"};function e(s,l,n,p,d,c){return o(),i("div",null,l[0]||(l[0]=[a('<h1 id="javascript-面试题汇总" tabindex="-1">javascript 面试题汇总 <a class="header-anchor" href="#javascript-面试题汇总" aria-label="Permalink to &quot;javascript 面试题汇总&quot;">​</a></h1><h2 id="var、let、const的区别-什么是块级作用域" tabindex="-1">var、let、const的区别？什么是块级作用域？ <a class="header-anchor" href="#var、let、const的区别-什么是块级作用域" aria-label="Permalink to &quot;var、let、const的区别？什么是块级作用域？&quot;">​</a></h2><ul><li>var：定义变量，有变量提升，可以跨块访问，没有块级作用域的概念，不能跨函数访问</li><li>let：es6新增的定义变量的方式，没有变量提升，不可以重复声明，有块级作用域的概念，</li><li>const： es6新增的定义常量的方式，没有变量提升，声明的变量不可修改，有块级作用域的概念。</li></ul><p>最初在js中，只有全局作用域、函数作用域，没有块级作用域的概念，在es6时，新增了块级作用域的概念。块级作用域解决了在for循环中声明变量泄漏成全局变量的问题</p><h2 id="js中的数据类型有哪些-基本类型和引用类型的区别是什么" tabindex="-1">JS中的数据类型有哪些？基本类型和引用类型的区别是什么？ <a class="header-anchor" href="#js中的数据类型有哪些-基本类型和引用类型的区别是什么" aria-label="Permalink to &quot;JS中的数据类型有哪些？基本类型和引用类型的区别是什么？&quot;">​</a></h2><p>JS中的数据类型分为两类：</p><ul><li>简单值（基础类型/原始类型）：简单值分为7中：String字符串类型、Boolean布尔值类型、Number数字类型、undefined、null、symbol符号类型，bigInt大数类型</li><li>复杂值（引用值/引用类型）：复杂值就一种，object，像数组、函数、正则这些统统都是对象类型，函数的本质也是对象，其内部有一个特别的属性[[call]],有了该属性，则标识该对象是可调用的，也区分了普通对象和函数对象，也因此设计使得JS中可以实现高阶函数。</li></ul><p>内存存储分为栈和堆：</p><ul><li>栈内存：栈内存因其数据大小和生命周期的可预测性而易于管理和快速访问。栈支持快速的数据分配和销毁过程</li><li>堆内存：堆内存更加灵活，可以动态的分配和释放空间，适合存储生命周期长活着大小不确定的数据。是用堆内存可以有效地管理大量的数据，但相对于栈来说，其管理成本更高，访问速度也更慢。</li></ul><p>对于简单值而言，其通常存储于栈内存，简单值的存储通常包括直接在栈内存中分配的数据空间，并且直接存储了数据的实际值</p><p>对于复杂值而言，具体的值是存储在堆内存离的，因为复杂值往往大小不固定，无法在栈区分配一个固定大小的内存，因此具体的数据放在堆里面，而栈区存储一个内存地址，通过该内存地址可以访问到堆区里面具体的数据。</p><p>JS中在调用函数时，通通都是值传递，而非引用传递。</p><ul><li><ol><li>访问方式：简单值是按值访问，也就是说，一个变量如果存储的是一个简单值，当访问这个变量的时候，得到的是对应值；复杂值虽然也是按值访问，但是由于值对应的是一个内存地址，不需要进一步获取地址值后对应的值。</li></ol></li><li><ol start="2"><li>比较方式：无论简单值还是复杂值，都是进行值的比较，不过由于复杂值对应的值是一个内存地址，因此，只有这个内存地址相同时，才会被认为是相等的。</li></ol></li><li><ol start="3"><li>动态属性： 对于复制值来说，可以动态的为其添加属性和方法，这一点是简单值做不到的，如果为简单值动态添加属性，不会报错，会静默失败，访问时返回的值为undefined，如果为简单值添加方法，则会报错</li></ol></li><li><ol start="4"><li>变量赋值：复杂值和简单值都是讲值复制一份然后赋值给另一个变量，不过由于复杂值复制的是内存地址，因此修改新的变量会对旧的有影响。</li></ol></li></ul><h2 id="是否了解javascript中的包装类型" tabindex="-1">是否了解javascript中的包装类型？ <a class="header-anchor" href="#是否了解javascript中的包装类型" aria-label="Permalink to &quot;是否了解javascript中的包装类型？&quot;">​</a></h2><p>包装对象就是当基本类型以对象的方式去使用时，js会转换成对应的包装类型，相当于new一个对象，内容和基本类型的内容一致，然后当操作完成再去访问的时候，这个临时对象会被销毁，然后在访问的时候就是undefined。</p><p>number、string、boolean都有对应的包装类型，有了基本包装类型，js中的基本类型值可以被当做对象来访问。</p><p>包装类型特征：</p><ul><li><ol><li>每个包装类型都映射到同名的基本类型</li></ol></li><li><ol start="2"><li>在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便数据操作。</li></ol></li><li><ol start="3"><li>操作基本类型值的语句一经执行完毕，就会立即销毁新建的包装对象。</li></ol></li></ul><h2 id="js中如何进行数据转化" tabindex="-1">JS中如何进行数据转化 <a class="header-anchor" href="#js中如何进行数据转化" aria-label="Permalink to &quot;JS中如何进行数据转化&quot;">​</a></h2><p>类型转换分为凉凉：隐式转换和显性转换</p><ul><li>隐式转换：当不同数据类型之间进行相互运算或者当对非布尔类型的数据求布尔值的时候，会发生隐式转换</li><li>显性转换：强制将一种类型转换为另一种类型，显性转换往往会使用到一些转换方法</li></ul><table tabindex="0"><thead><tr><th>类型</th><th>转换方法</th><th></th></tr></thead><tbody><tr><td>数值类型</td><td>Number()、parseInt()、parseFloat</td><td>a= +数据</td></tr><tr><td>布尔类型</td><td>Boolean()</td><td>!!</td></tr><tr><td>字符串类型</td><td>toString()、string()</td><td>&#39;&#39;+</td></tr></tbody></table><h2 id="谈谈你对js中原型和原型链的理解" tabindex="-1">谈谈你对js中原型和原型链的理解 <a class="header-anchor" href="#谈谈你对js中原型和原型链的理解" aria-label="Permalink to &quot;谈谈你对js中原型和原型链的理解&quot;">​</a></h2><p>不同的语言，生产对象的方式并不相同，大致可以分为两类：</p><ul><li><ol><li>基于类生产对象。基于类生产，首先要书写一个类，然后通过类实例化对象。</li></ol></li><li><ol start="2"><li>基于原型生产对象。基于原型生产，就现有一个对象A，然后想要一个B，就从B克隆一份对象得到B，新的对象B可以添加新的属性和方法，对于B而言，对象A就是自己的原型对象</li></ol></li></ul><p>在设计js时，就选择了原型的方式来生产对象，所以，在js中，无论这个对象是如何书写的，该对象都有自己的原型对象。在ES6之前，因为Java等面向对象语言的盛行，设计者不仅添加了this、new等关键词，还是用构造函数（即不成文约定的函数首字母大写）来模拟类。构建函数本身就是函数，但是如果使用new 的方式来调用。执行机制则和普通函数不同，这也是函数二义性的由来。构造函数执行机制如下：</p><ul><li><ol><li>创建一个空的JS对象</li></ol></li><li><ol start="2"><li>设置该对象的原型对象，将该对象属性链接至构造函数的原型对象上</li></ol></li><li><ol start="3"><li>设置this的上下文</li></ol></li><li><ol start="4"><li>如果该函数没有返回对象，则返回this</li></ol></li></ul><p>在js中，只要是由构造函数new 出来的对象，都满足这样的关系，不管是自定义构造函数还是内置的构造函数还是内置的构造函数。</p><p>js中的对象大体上分两大类：普通对象和构造器对象</p><ul><li><ol><li>无论是普通对象还是构造器对象，都会有自己的原型对象，通过 <strong>proto</strong> 这个隐式属性，找到自己的原型对象，并且一直向上找，最终到达null</li></ol></li><li><ol start="2"><li>普通对象和构造器对象区别在于是否能够实例化，构造器对象可以通过new 的形式创建新的实例对象</li></ol></li><li><ol start="3"><li>只有构造器对象才有prototype属性，其prototype属性指向实例对象的原型对象</li></ol></li><li><ol start="4"><li>所有构造器对象的原型对象均为Function.prototype</li></ol></li><li><ol start="5"><li>无论是普通对象还是构造器对象，最终的 constructor 指向 Function，而 Function的constructor指向自己本身</li></ol></li><li><ol start="6"><li>Object的构造函数对象比较特殊，实例化出来的对象的原型对象直接是Object.prototype，而其它的构造器对象，其实例对象的原型对象为对应的xxx.prototype,在往上一层才是Object.prototype</li></ol></li></ul>',30)]))}const j=t(r,[["render",e]]);export{h as __pageData,j as default};
