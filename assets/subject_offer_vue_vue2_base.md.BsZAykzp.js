import{_ as a,c as t,a0 as l,o as i}from"./chunks/framework.CSihnngI.js";const f=JSON.parse('{"title":"Vue2面试题汇总","description":"","frontmatter":{},"headers":[],"relativePath":"subject/offer/vue/vue2/base.md","filePath":"subject/offer/vue/vue2/base.md","lastUpdated":1750953333000}'),u={name:"subject/offer/vue/vue2/base.md"};function r(o,e,d,s,p,n){return i(),t("div",null,e[0]||(e[0]=[l('<h1 id="vue2面试题汇总" tabindex="-1">Vue2面试题汇总 <a class="header-anchor" href="#vue2面试题汇总" aria-label="Permalink to &quot;Vue2面试题汇总&quot;">​</a></h1><h2 id="谈谈你对vue的理解" tabindex="-1">谈谈你对Vue的理解？ <a class="header-anchor" href="#谈谈你对vue的理解" aria-label="Permalink to &quot;谈谈你对Vue的理解？&quot;">​</a></h2><ul><li><p>vue是一个用于创建用户界面的开源JavaScript库，也是一个创建单页应用的Web应用框架。其核心特性是数据驱动（受 MVVM 模式启发）界面变化。其主要优点有响应式编程、组件化开发、虚拟dom。</p></li><li><p>vue是一个声明式框架，声明式框架的好处在于其只关注结果，无须关注过程。vue采用模版的方式来描述UI，但其同样支持虚拟DOM来描述UI。虚拟DOM比模版更加灵活，但是模版比虚拟DOM更加直观。</p></li><li><p>当用户使用模版来描述UI时，内部的编译器会将其编译为渲染函数，渲染函数执行后能够确定响应式数据和渲染函数之间的依赖关系，之后响应式数据一变化，渲染函数就会重新执行。</p></li><li><p>渲染函数执行的结果是得到虚拟DOM，之后就需要渲染器将虚拟DOM对象渲染为真实的DOM元素。它的工作原来是递归的遍历虚拟DOM对象，并调用原生DOM API 来完成成真实DOM的创建。渲染器的精髓在于后续的更新，它会通过Diff算法找到变更点，并且只会更新需要更新的内容。</p></li></ul><p>编译器、渲染器、响应系统都是vue内部的核心模块，他们构成了一个整体，不同模块之间互相配合。</p><h2 id="什么是-vue-生命周期" tabindex="-1">什么是 vue 生命周期？ <a class="header-anchor" href="#什么是-vue-生命周期" aria-label="Permalink to &quot;什么是 vue 生命周期？&quot;">​</a></h2><p>对于 vue 来讲，生命周期就是一个 vue 实例从创建到销毁的过程。在生命周期的过程中会运行着一些叫做生命周期的函数，给予了开发者在不同的生命周期阶段添加业务代码的能力。</p><p>vue生命周期总分为8个阶段：创建前/创建后、挂载前/挂载后、更新前/更新后、销毁前/销毁后</p><ul><li>beforeCreate：是 new Vue( ) 之后触发的第一个钩子，在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。</li><li>created：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。可以做一些初始数据的获取，在当前阶段无法与 DOM 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 DOM 。</li><li>beforeMount：发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 DOM 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated。</li><li>mounted：在挂载完成后发生，在当前阶段，真实的 DOM 挂载完毕，数据完成双向绑定，可以访问到 DOM 节点，使用 $refs 属性对 DOM 进行操作。</li><li>beforeUpdate：发生在更新之前，也就是响应式数据发生更新，虚拟 DOM 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</li><li>updated：发生在更新完成之后，当前阶段组件 DOM 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</li><li>beforeDestroy：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</li><li>destroyed：发生在实例销毁之后，这个时候只剩下了 DOM 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</li></ul><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h2>',9)]))}const v=a(u,[["render",r]]);export{f as __pageData,v as default};
