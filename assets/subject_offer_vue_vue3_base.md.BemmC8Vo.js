import{_ as o,c as i,a0 as a,o as u}from"./chunks/framework.CSihnngI.js";const p=JSON.parse('{"title":"vue3 面试题汇总","description":"","frontmatter":{},"headers":[],"relativePath":"subject/offer/vue/vue3/base.md","filePath":"subject/offer/vue/vue3/base.md","lastUpdated":1750953333000}'),l={name:"subject/offer/vue/vue3/base.md"};function t(c,e,d,r,s,v){return u(),i("div",null,e[0]||(e[0]=[a('<h1 id="vue3-面试题汇总" tabindex="-1">vue3 面试题汇总 <a class="header-anchor" href="#vue3-面试题汇总" aria-label="Permalink to &quot;vue3 面试题汇总&quot;">​</a></h1><h2 id="vue3相比vue2有什么变化" tabindex="-1">vue3相比vue2有什么变化？ <a class="header-anchor" href="#vue3相比vue2有什么变化" aria-label="Permalink to &quot;vue3相比vue2有什么变化？&quot;">​</a></h2><p><code>vue3</code>相比<code>vue2</code>的整体变化可以大致分类四类。分别是<code>源码优化</code>、<code>性能优化</code>、<code>语法api优化</code>及引入<code>RFC</code></p><ul><li><p>源码优化：</p><ol><li>使用ts重构了整个vue</li><li>对vue2中冷门的功能进行了删除（如<code>inline-template</code>、<code>filter</code>等）</li><li>使用monorepo重构了整个项目架构，将vue每个功能模块单独分包，使得整个框架更具有颗粒度，每个功能模块都可以单独引入使用</li></ol></li><li><p>性能优化： 性能上的优化是最核心的变化，vue3重构优化了响应式、diff算法、模版编译，整体相比vue2性能有了飞跃的提升</p></li><li><p>语法api优化: 体现在新增了<code>composition Api</code>, 用于替代vue2时期的<code>option Api</code>,这种语法结构让功能逻辑代码更加集中。另外，<code>conposition Api</code> 让代码的颗粒度上更细，不需要再像之前使用<code>mixin</code>复用逻辑</p></li><li><p>RFC(Request For Comments) 引入了RFC的流程来处理新功能和重大更改</p></li></ul><h2 id="为什么vue3去掉了vue2时的构造函数" tabindex="-1">为什么Vue3去掉了vue2时的构造函数 <a class="header-anchor" href="#为什么vue3去掉了vue2时的构造函数" aria-label="Permalink to &quot;为什么Vue3去掉了vue2时的构造函数&quot;">​</a></h2><p>vue2的全局构造函数带来了很多问题：</p><ul><li><ol><li>调用构造函数的静态方法会对所有vue应用生效，不利于隔离不同的应用</li></ol></li><li><ol start="2"><li>Vue2的构造函数集成了太多功能，不利于tree sharking；vue3把这些功能使用普通函数导出，能够充分利用tree sharking进行优化打包</li></ol></li><li><ol start="3"><li>Vue2没有把组件实例和Vue应用两个概念分开，在Vue2中，通过new Vue()创建的对象，既是一个vue应用，又是一个特殊的vue组件，没有把两个概念区别开来，通过createApp创建的对象是一个Vue应用，它内部提供的方法是针对整个应用的，而不再是一个特殊的组件</li></ol></li></ul>',7)]))}const _=o(l,[["render",t]]);export{p as __pageData,_ as default};
