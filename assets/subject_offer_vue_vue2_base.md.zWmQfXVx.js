import{_ as l,c as a,a0 as t,o as i}from"./chunks/framework.CSihnngI.js";const v=JSON.parse('{"title":"Vue2面试题汇总","description":"","frontmatter":{},"headers":[],"relativePath":"subject/offer/vue/vue2/base.md","filePath":"subject/offer/vue/vue2/base.md","lastUpdated":1751166161000}'),r={name:"subject/offer/vue/vue2/base.md"};function u(o,e,p,d,s,c){return i(),a("div",null,e[0]||(e[0]=[t('<h1 id="vue2面试题汇总" tabindex="-1">Vue2面试题汇总 <a class="header-anchor" href="#vue2面试题汇总" aria-label="Permalink to &quot;Vue2面试题汇总&quot;">​</a></h1><h2 id="谈谈你对vue的理解" tabindex="-1">谈谈你对Vue的理解？ <a class="header-anchor" href="#谈谈你对vue的理解" aria-label="Permalink to &quot;谈谈你对Vue的理解？&quot;">​</a></h2><ul><li><p>vue是一个用于创建用户界面的开源JavaScript库，也是一个创建单页应用的Web应用框架。其核心特性是数据驱动（受 MVVM 模式启发）界面变化。其主要优点有响应式编程、组件化开发、虚拟dom。</p></li><li><p>vue是一个声明式框架，声明式框架的好处在于其只关注结果，无须关注过程。vue采用模版的方式来描述UI，但其同样支持虚拟DOM来描述UI。虚拟DOM比模版更加灵活，但是模版比虚拟DOM更加直观。</p></li><li><p>当用户使用模版来描述UI时，内部的编译器会将其编译为渲染函数，渲染函数执行后能够确定响应式数据和渲染函数之间的依赖关系，之后响应式数据一变化，渲染函数就会重新执行。</p></li><li><p>渲染函数执行的结果是得到虚拟DOM，之后就需要渲染器将虚拟DOM对象渲染为真实的DOM元素。它的工作原来是递归的遍历虚拟DOM对象，并调用原生DOM API 来完成成真实DOM的创建。渲染器的精髓在于后续的更新，它会通过Diff算法找到变更点，并且只会更新需要更新的内容。</p></li></ul><p>编译器、渲染器、响应系统都是vue内部的核心模块，他们构成了一个整体，不同模块之间互相配合。</p><h2 id="什么是-vue-生命周期" tabindex="-1">什么是 vue 生命周期？ <a class="header-anchor" href="#什么是-vue-生命周期" aria-label="Permalink to &quot;什么是 vue 生命周期？&quot;">​</a></h2><p>对于 vue 来讲，生命周期就是一个 vue 实例从创建到销毁的过程。在生命周期的过程中会运行着一些叫做生命周期的函数，给予了开发者在不同的生命周期阶段添加业务代码的能力。</p><p>vue生命周期总分为8个阶段：创建前/创建后、挂载前/挂载后、更新前/更新后、销毁前/销毁后</p><ul><li>beforeCreate：是 new Vue( ) 之后触发的第一个钩子，在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。</li><li>created：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。可以做一些初始数据的获取，在当前阶段无法与 DOM 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 DOM 。</li><li>beforeMount：发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 DOM 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated。</li><li>mounted：在挂载完成后发生，在当前阶段，真实的 DOM 挂载完毕，数据完成双向绑定，可以访问到 DOM 节点，使用 $refs 属性对 DOM 进行操作。</li><li>beforeUpdate：发生在更新之前，也就是响应式数据发生更新，虚拟 DOM 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</li><li>updated：发生在更新完成之后，当前阶段组件 DOM 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</li><li>beforeDestroy：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</li><li>destroyed：发生在实例销毁之后，这个时候只剩下了 DOM 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</li></ul><h2 id="vue响应式的原理的理解" tabindex="-1">Vue响应式的原理的理解？ <a class="header-anchor" href="#vue响应式的原理的理解" aria-label="Permalink to &quot;Vue响应式的原理的理解？&quot;">​</a></h2><p>Vue2的响应式原理核心是通过<code>数据劫持结合发布-订阅模式</code>实现的，主要有三个关键部分：</p><ul><li><p>数据劫持：Vue使用<code>Object.defineProperty</code>递归的将data对象的所有属性转换为getter/setter，在属性被访问和修改时，能够追踪依赖和触发更新</p></li><li><p>依赖收集：在getter中，每个属性会有一个对应的Dep依赖管理。当组件渲染时，触发的getter会将当前的Wather（组件渲染函数）添加到Dep的订阅列表中。</p></li><li><p>派发更新：当数据变化触发setter时，会通知Dep中所有订阅的Watcher进行更新，Watcher会重新执行组件渲染函数，完成视图更新。</p></li></ul><p>这种机制使得Vue能够自动追踪数据依赖，在数据变化时高效地更新相关视图部分，而不需要开发者手动操作DOM。</p><h2 id="v-model双向绑定的原理" tabindex="-1">v-model双向绑定的原理 <a class="header-anchor" href="#v-model双向绑定的原理" aria-label="Permalink to &quot;v-model双向绑定的原理&quot;">​</a></h2><p>v-model本质是：value+input方法的语法糖。可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。 如：</p><ul><li>input和textare元素使用value属性和input事件</li><li>checkbox和radio使用checked属性和change事件</li><li>select字段将value作为prop并将change作为事件</li></ul><p>以输入框为例，当用户在输入框输入内容时，会触发input事件，从而更新value。而value的改变同样会更新视图，这就是vue中的双向绑定。双向绑定的原理，其实现思路如下：</p><ul><li>对数据进行监听劫持，需要设置一个监听器Observer，用来监听所有属性。如果属性发生了变化，就需要告诉订阅者Wather看是否需要更新。</li><li>因为订阅者有多个，所以我们需要一个订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Wather之间进行统一管理</li><li>接着，我们还需要一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订货约着Wather，并替换模版数据或者绑定响应的函数，此时当订阅者Wather接收到响应属性的变化，就会执行对应的更新函数，从而更新视图</li></ul><p>因此需要执行3个步骤实现数据的双向绑定：</p><ul><li><ol><li>实现一个监听器Observer，用来劫持并监听所有属性，如果有变动，就通知订阅者。</li></ol></li><li><ol start="2"><li>实现一个订阅者Wather，可以收到属性的变化通知并执行响应的函数，从而更新视图。</li></ol></li><li><ol start="3"><li>实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模版数据以及初始化相应的订阅器。</li></ol></li></ul>',19)]))}const h=l(r,[["render",u]]);export{v as __pageData,h as default};
