import{_ as t,c as a,a0 as r,o as l}from"./chunks/framework.CSihnngI.js";const m=JSON.parse('{"title":"策略模式","description":"","frontmatter":{},"headers":[],"relativePath":"article/designPattern/3_8_modelCreated_strategy.md","filePath":"article/designPattern/3_8_modelCreated_strategy.md","lastUpdated":1732712300000}'),o={name:"article/designPattern/3_8_modelCreated_strategy.md"};function i(n,e,s,_,d,c){return l(),a("div",null,e[0]||(e[0]=[r('<h1 id="策略模式" tabindex="-1">策略模式 <a class="header-anchor" href="#策略模式" aria-label="Permalink to &quot;策略模式&quot;">​</a></h1><blockquote><p>定义一系列的<strong>算法</strong>，将其一一<strong>封装</strong>，并且使他们可以相互<strong>替换</strong>。策略模式的核心思想是将算法的实现与使用算法的代码分离，从而使得算法的变化独立于使用算法的客户端</p><ul><li>算法：任何功能函数的逻辑</li><li>封装：把某一功能点对应的逻辑提取出来</li><li>替换：把某一功能点对应的逻辑提出来；可替换建立在封装的基础上，只能说这个替换的判断过程，不能 if-else，而需要考虑更有的映射方案</li></ul></blockquote><h2 id="策略模式的组成部分" tabindex="-1">策略模式的组成部分 <a class="header-anchor" href="#策略模式的组成部分" aria-label="Permalink to &quot;策略模式的组成部分&quot;">​</a></h2><ul><li>策略接口（Strategy Interface）： 定义一个公共接口，所有具体策略都要实现这个接口</li><li>具体策略（Concrete Strategies）：实现策略接口的具体算法或行为</li><li>上下文（Context）：持有一个策略对象的引用，并可以在运行时选择和切换不同的策略</li></ul>',4)]))}const u=t(o,[["render",i]]);export{m as __pageData,u as default};
