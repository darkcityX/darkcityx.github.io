import{_ as a,c as l,a0 as s,o as t}from"./chunks/framework.CSihnngI.js";const u=JSON.parse('{"title":"算法","description":"","frontmatter":{},"headers":[],"relativePath":"majorTopic/dataAndAlgorithm/03_algorithm.md","filePath":"majorTopic/dataAndAlgorithm/03_algorithm.md","lastUpdated":1730739594000}'),n={name:"majorTopic/dataAndAlgorithm/03_algorithm.md"};function e(r,i,h,d,p,o){return t(),l("div",null,i[0]||(i[0]=[s(`<h1 id="算法" tabindex="-1">算法 <a class="header-anchor" href="#算法" aria-label="Permalink to &quot;算法&quot;">​</a></h1><h2 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h2><p>定义为一个有穷的指令集，这些指令为解决某一特定任务规定了一个运算序列</p><ul><li>输入（0/m）</li><li>输出（0/1）</li><li>有穷性</li><li>确定性</li><li>可行性</li></ul><h2 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h2><ul><li>分治算法</li><li>动态规划算法</li><li>贪婪算法</li><li>树状搜索算法</li><li>......</li></ul><h2 id="描述" tabindex="-1">描述 <a class="header-anchor" href="#描述" aria-label="Permalink to &quot;描述&quot;">​</a></h2><ul><li>语言方式</li><li>图形方式</li><li>表格方式</li></ul><h2 id="性能标准" tabindex="-1">性能标准 <a class="header-anchor" href="#性能标准" aria-label="Permalink to &quot;性能标准&quot;">​</a></h2><ol><li>正确性：要求算法能够正确地执行预定的功能和性能要求</li></ol><ul><li>没有语法错误</li><li>对于合法的输入能产生满足要求的输出</li><li>对于非法输入能得出满足规格说明的结果</li><li>对于精心选择的，刁难的测试有满足要求的输出</li></ul><ol start="2"><li>可使用性：要求算法能够很方便的使用</li></ol><ul><li>抽象数据类型或模块化</li><li>输入输出通过参数表显式传递</li><li>少用公用或全局变量</li><li>一个算法一个功能</li></ul><ol start="3"><li>可读性：算法应当是可读的</li></ol><ul><li>算法逻辑（清晰、简单、结构化）</li><li>变量名、函数名</li><li>注释</li></ul><ol start="4"><li><p>健壮性：要求在算法中加入对输入参数、打开文件、对文件记录、子程序调用状态进行自动检错、报错并通过与用户对话来纠错的能力</p></li><li><p>简单性：指一个算法所采用数据结构和方法的简单程度。</p></li></ol><ul><li>简单-&gt;出错率低-&gt;可靠性高</li></ul><ol start="6"><li>效率：指算法执行时计算机资源的消耗，包括存储和运行时间的开销。</li></ol><h2 id="算法效率的度量方法" tabindex="-1">算法效率的度量方法 <a class="header-anchor" href="#算法效率的度量方法" aria-label="Permalink to &quot;算法效率的度量方法&quot;">​</a></h2><p>分析算法占用的资源</p><ul><li>CPU 时间：时间性能分析</li><li>内存控件: 空间性能分析</li></ul><p>算法效率的度量的目的：分析算法的时空效率以便改进算法性能</p><h3 id="后期测试" tabindex="-1">后期测试 <a class="header-anchor" href="#后期测试" aria-label="Permalink to &quot;后期测试&quot;">​</a></h3><p>主要通过在算法中的某些部位插装时间函数来测定算法完成某一规定功能所需要的时间</p><ul><li>必须实现编制好程序</li><li>算法的运行时间以来于所用的计算机系统、编辑器、可用存储空间大小</li><li>算法的测试数据设计器困难，并且程序的运行时间往往还与测试数据的规模有很大的关系</li></ul><h3 id="事前估计" tabindex="-1">事前估计 <a class="header-anchor" href="#事前估计" aria-label="Permalink to &quot;事前估计&quot;">​</a></h3><ol><li>在计算机程序编制前，依据统计方法对算法进行估算</li></ol><ul><li>算法采用的策略、方法</li><li>编译产生的代码质量</li><li>问题的输入规模</li><li>机器执行指令的速度</li></ul><ol start="2"><li>算法的复杂性的度量属于事前估计</li></ol><ul><li>时间复杂度</li><li>控件复杂度</li></ul><h3 id="计算时间复杂度" tabindex="-1">计算时间复杂度 <a class="header-anchor" href="#计算时间复杂度" aria-label="Permalink to &quot;计算时间复杂度&quot;">​</a></h3><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><table tabindex="0"><thead><tr><th>一次性执行所需的程序步骤</th><th>执行次数</th><th>程序步骤</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>n+1</td><td>2n+2</td></tr><tr><td>1</td><td>n</td><td>n</td></tr><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td></tr></tbody></table><p>总程序步骤数：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>T(n) = 0+1+2n+2+n+1+0</span></span>
<span class="line"><span>     = 3n+4</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol><li>大 O 记号</li></ol>`,36)]))}const c=a(n,[["render",e]]);export{u as __pageData,c as default};
