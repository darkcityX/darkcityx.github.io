import{_ as l,c as a,a0 as r,o as t}from"./chunks/framework.CSihnngI.js";const o="/images/microFrontend/01.png",e="/images/microFrontend/02.png",n="/images/microFrontend/03.png",f=JSON.parse('{"title":"微前端","description":"","frontmatter":{},"headers":[],"relativePath":"article/microFrontend/index.md","filePath":"article/microFrontend/index.md","lastUpdated":1751210248000}'),s={name:"article/microFrontend/index.md"};function h(p,i,c,d,g,m){return t(),a("div",null,i[0]||(i[0]=[r('<h1 id="微前端" tabindex="-1">微前端 <a class="header-anchor" href="#微前端" aria-label="Permalink to &quot;微前端&quot;">​</a></h1><h2 id="why-为什么使用微前端" tabindex="-1">Why（为什么使用微前端？） <a class="header-anchor" href="#why-为什么使用微前端" aria-label="Permalink to &quot;Why（为什么使用微前端？）&quot;">​</a></h2><ul><li><ol><li>为了平稳升级旧项目，并且可在该项目工程上可持续迭代加新功能。</li></ol></li><li><ol start="2"><li>为了保证该项目有持续的生命力，不会变成一个遗产项目</li></ol></li><li><ol start="4"><li>为了维持技术的多样应，如原生 js、jq、vue、react 可接入同一工程</li></ol></li><li><ol start="3"><li>为了保障多团队开发，统一入口管理和项目代码整合度</li></ol></li><li><ol start="5"><li>为了将巨石应用拆分成各个单独的模块，能保证其独立开发、独立运行、单独部署</li></ol></li></ul><p>最终目的是要求：<strong>各个业务模块之间隔离、最好技术栈无关、具备独立开发、独立部署和可以增量扩展迁移</strong>的特点。</p><h2 id="what-什么是微前端" tabindex="-1">What（什么是微前端？） <a class="header-anchor" href="#what-什么是微前端" aria-label="Permalink to &quot;What（什么是微前端？）&quot;">​</a></h2><p>微前端：是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 WEB 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行，独立开发、独立部署。<strong>微前端不是单纯的前端框架或工具，而是一套架构体系</strong>，而这套架构体系也有很多的实现方式。</p><h3 id="对比-普通单体应用-vs-多页应用-多个单体应用-vs-微前端应用" tabindex="-1">对比：普通单体应用 vs 多页应用/多个单体应用 vs 微前端应用 <a class="header-anchor" href="#对比-普通单体应用-vs-多页应用-多个单体应用-vs-微前端应用" aria-label="Permalink to &quot;对比：普通单体应用 vs 多页应用/多个单体应用 vs 微前端应用&quot;">​</a></h3><p>普通单体应用 <img src="'+o+'" alt="普通单体应用"></p><p>多页应用/多个单体应用 <img src="'+e+'" alt="多页应用/多个单体应用"></p><p>微前端应用 <img src="'+n+'" alt="微前端应用"></p><h2 id="where-什么场景下适用微前端" tabindex="-1">Where（什么场景下适用微前端？） <a class="header-anchor" href="#where-什么场景下适用微前端" aria-label="Permalink to &quot;Where（什么场景下适用微前端？）&quot;">​</a></h2><p>理想场景下：</p><ul><li><strong>大型复杂企业级应用：</strong> 拥有多个相对独立功能模块或产品线（如大型电商后台、ERP、CRM、SaaS 平台）。</li><li><strong>需要整合遗留系统：</strong> 将老旧的（可能是不同技术栈的）前端逐步替换或集成到新框架中。</li><li><strong>多团队协作开发：</strong> 需要多个团队并行开发不同功能，且希望团队拥有技术选型自由。</li><li><strong>需要独立部署能力：</strong> 要求不同功能模块能独立上线，不影响其他部分。</li></ul><p>不适用或谨慎的场景：</p><ul><li><strong>小型或简单应用：</strong> 引入微前端会增加不必要的复杂度和开销。</li><li><strong>对首次加载性能极其敏感的应用：</strong> 动态加载和集成可能带来额外开销（可通过优化缓解）。</li><li><strong>没有明确功能边界或模块高度耦合的应用：</strong> 难以拆分。</li><li><strong>团队规模小、技术栈统一且沟通顺畅：</strong> 单体应用可能更高效。</li><li><strong>缺乏必要的基础设施和工程化能力。</strong></li></ul><h2 id="when-何时引入微前端" tabindex="-1">When（何时引入微前端？） <a class="header-anchor" href="#when-何时引入微前端" aria-label="Permalink to &quot;When（何时引入微前端？）&quot;">​</a></h2><p>触发时机：</p><ul><li>现有单体前端应用变得难以维护、构建缓慢、团队协作效率低下时。</li><li>需要引入与现有技术栈不同的新功能/模块时。</li><li>计划对大型应用进行大规模重构或技术栈升级时（可作为过渡策略）。</li><li>产品需要支持不同团队独立负责不同子产品/模块，并希望快速迭代时。</li></ul><p>实施策略：</p><ul><li><strong>增量采用：</strong> 最常见。从现有单体中逐步拆分出模块成为微应用，或在新功能中使用微前端。</li><li><strong>绿地开发：</strong> 全新项目，从一开始就按微前端架构设计（需评估风险）。</li><li><strong>评估成本收益：</strong> 明确引入微前端要解决的具体问题，评估带来的复杂度增加是否值得。</li></ul><h2 id="who-谁来负责-参与" tabindex="-1">Who(谁来负责/参与？) <a class="header-anchor" href="#who-谁来负责-参与" aria-label="Permalink to &quot;Who(谁来负责/参与？)&quot;">​</a></h2><ul><li><p><strong>架构师/技术负责人：</strong></p><ul><li>设计整体架构（集成方式、通信机制、路由方案、共享策略）。</li><li>制定技术规范和标准（如微应用接口、通信协议）。</li><li>选择合适的技术方案和工具链。</li></ul></li><li><p><strong>开发团队：</strong></p><ul><li><strong>基座/容器团队：</strong> 负责开发维护主应用，提供核心服务（路由、加载、通信总线、共享库管理）。</li><li><strong>微应用团队：</strong> 独立负责各自微应用的开发、测试、构建、部署（端到端职责）。</li><li>遵守约定的接口和规范，确保集成兼容性。</li></ul></li><li><p><strong>运维/平台团队：</strong></p><ul><li>搭建支持独立部署的 CI/CD 流水线。</li><li>提供微应用注册、发现、监控的平台或基础设施。</li><li>管理共享依赖的部署和版本控制。</li></ul></li><li><p><strong>测试团队：</strong></p><ul><li>制定集成测试策略（微应用间、微应用与基座间）。</li><li>进行端到端测试，确保整体用户体验一致。</li><li>支持微应用的独立测试。</li></ul></li></ul><h2 id="how-如何实现微前端" tabindex="-1">How（如何实现微前端？） <a class="header-anchor" href="#how-如何实现微前端" aria-label="Permalink to &quot;How（如何实现微前端？）&quot;">​</a></h2><h3 id="iframe-方案" tabindex="-1">iframe 方案 <a class="header-anchor" href="#iframe-方案" aria-label="Permalink to &quot;iframe 方案&quot;">​</a></h3><p>在正常的项目开发中，如果一个项目中嵌入另外一个项目的页面，普遍的思路都是 iframe，而且 iframe 本身具有天然的隔离特性，不需要考虑各个项目之间 css、js 的冲突问题，但是正因为它的隔离性无法突破，从而导致应用之间上下文无法被共享，造成开发、产品体验的问题：</p><ul><li>URL 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用；</li><li>UI 不同步，DOM 结构不共享，iframe 内部弹窗浮层不能展示在页面中心、遮罩只能遮住 iframe；</li><li>全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。iframe 内部错误也无法监控</li><li>页面加载速度慢；每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程</li></ul><h3 id="基于-nginx-路由分发" tabindex="-1">基于 Nginx 路由分发 <a class="header-anchor" href="#基于-nginx-路由分发" aria-label="Permalink to &quot;基于 Nginx 路由分发&quot;">​</a></h3><p>方案：通过路由将不同的业务分发到不同的、独立的前端应用上。通常使用 <strong>HTTP 服务器的反向代理</strong>来实现。</p><p>例如www.abc.com/app1对应app1，www.abc.com/app2对应app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置，当然这么做优点十分明显了，简单，快速，易配置。缺点其实也和iframe差不多，iframe有的缺点他都有，比如在切换应用时触发发页面刷新，项目之间通信不易</p><h3 id="基于-npm-的集成" tabindex="-1">基于 NPM 的集成 <a class="header-anchor" href="#基于-npm-的集成" aria-label="Permalink to &quot;基于 NPM 的集成&quot;">​</a></h3><p>将子应用封装成 npm 包，通过组件的方式引入，在性能和兼容性上是最优的方案，但却有一个致命的问题就是版本更新，每次版本发布需要通知接入方同步更新，管理非常困难。而且也不可能成为一种长期维护的架构选择，随着时间的推移，系统越来越臃肿，不同 npm 之间的管理会越来越困难，特别是如果还有关键人员的变动的话。</p><h3 id="微前端框架" tabindex="-1">微前端框架 <a class="header-anchor" href="#微前端框架" aria-label="Permalink to &quot;微前端框架&quot;">​</a></h3>',32)]))}const _=l(s,[["render",h]]);export{f as __pageData,_ as default};
