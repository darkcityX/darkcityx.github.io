import{_ as i,c as a,a0 as n,o as l}from"./chunks/framework.CSihnngI.js";const e="/images/microFrontend/01.png",p="/images/microFrontend/02.png",t="/images/microFrontend/03.png",r="/images/microFrontend/05.png",h="/images/microFrontend/04.png",k="/images/microFrontend/06.png",o="/images/microFrontend/07.png",F=JSON.parse('{"title":"微前端","description":"","frontmatter":{},"headers":[],"relativePath":"article/microFrontend/index.md","filePath":"article/microFrontend/index.md","lastUpdated":1751210248000}'),d={name:"article/microFrontend/index.md"};function c(g,s,E,u,m,b){return l(),a("div",null,s[0]||(s[0]=[n('<h1 id="微前端" tabindex="-1">微前端 <a class="header-anchor" href="#微前端" aria-label="Permalink to &quot;微前端&quot;">​</a></h1><h2 id="why-为什么使用微前端" tabindex="-1">Why（为什么使用微前端？） <a class="header-anchor" href="#why-为什么使用微前端" aria-label="Permalink to &quot;Why（为什么使用微前端？）&quot;">​</a></h2><ul><li><ol><li>为了平稳升级旧项目，并且可在该项目工程上可持续迭代加新功能。</li></ol></li><li><ol start="2"><li>为了保证该项目有持续的生命力，不会变成一个遗产项目</li></ol></li><li><ol start="4"><li>为了维持技术的多样应，如原生 js、jq、vue、react 可接入同一工程</li></ol></li><li><ol start="3"><li>为了保障多团队开发，统一入口管理和项目代码整合度</li></ol></li><li><ol start="5"><li>为了将巨石应用拆分成各个单独的模块，能保证其独立开发、独立运行、单独部署</li></ol></li></ul><p>最终目的是要求：<strong>各个业务模块之间隔离、最好技术栈无关、具备独立开发、独立部署和可以增量扩展迁移</strong>的特点。</p><h2 id="what-什么是微前端" tabindex="-1">What（什么是微前端？） <a class="header-anchor" href="#what-什么是微前端" aria-label="Permalink to &quot;What（什么是微前端？）&quot;">​</a></h2><p>微前端：是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 WEB 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行，独立开发、独立部署。<strong>微前端不是单纯的前端框架或工具，而是一套架构体系</strong>，而这套架构体系也有很多的实现方式。</p><h3 id="对比-普通单体应用-vs-多页应用-多个单体应用-vs-微前端应用" tabindex="-1">对比：普通单体应用 vs 多页应用/多个单体应用 vs 微前端应用 <a class="header-anchor" href="#对比-普通单体应用-vs-多页应用-多个单体应用-vs-微前端应用" aria-label="Permalink to &quot;对比：普通单体应用 vs 多页应用/多个单体应用 vs 微前端应用&quot;">​</a></h3><p>普通单体应用 <img src="'+e+'" alt="普通单体应用"></p><p>多页应用/多个单体应用 <img src="'+p+'" alt="多页应用/多个单体应用"></p><p>微前端应用 <img src="'+t+'" alt="微前端应用"></p><h2 id="where-什么场景下适用微前端" tabindex="-1">Where（什么场景下适用微前端？） <a class="header-anchor" href="#where-什么场景下适用微前端" aria-label="Permalink to &quot;Where（什么场景下适用微前端？）&quot;">​</a></h2><p>理想场景下：</p><ul><li><strong>大型复杂企业级应用：</strong> 拥有多个相对独立功能模块或产品线（如大型电商后台、ERP、CRM、SaaS 平台）。</li><li><strong>需要整合遗留系统：</strong> 将老旧的（可能是不同技术栈的）前端逐步替换或集成到新框架中。</li><li><strong>多团队协作开发：</strong> 需要多个团队并行开发不同功能，且希望团队拥有技术选型自由。</li><li><strong>需要独立部署能力：</strong> 要求不同功能模块能独立上线，不影响其他部分。</li></ul><p>不适用或谨慎的场景：</p><ul><li><strong>小型或简单应用：</strong> 引入微前端会增加不必要的复杂度和开销。</li><li><strong>对首次加载性能极其敏感的应用：</strong> 动态加载和集成可能带来额外开销（可通过优化缓解）。</li><li><strong>没有明确功能边界或模块高度耦合的应用：</strong> 难以拆分。</li><li><strong>团队规模小、技术栈统一且沟通顺畅：</strong> 单体应用可能更高效。</li><li><strong>缺乏必要的基础设施和工程化能力。</strong></li></ul><h2 id="when-何时引入微前端" tabindex="-1">When（何时引入微前端？） <a class="header-anchor" href="#when-何时引入微前端" aria-label="Permalink to &quot;When（何时引入微前端？）&quot;">​</a></h2><p>触发时机：</p><ul><li>现有单体前端应用变得难以维护、构建缓慢、团队协作效率低下时。</li><li>需要引入与现有技术栈不同的新功能/模块时。</li><li>计划对大型应用进行大规模重构或技术栈升级时（可作为过渡策略）。</li><li>产品需要支持不同团队独立负责不同子产品/模块，并希望快速迭代时。</li></ul><p>实施策略：</p><ul><li><strong>增量采用：</strong> 最常见。从现有单体中逐步拆分出模块成为微应用，或在新功能中使用微前端。</li><li><strong>绿地开发：</strong> 全新项目，从一开始就按微前端架构设计（需评估风险）。</li><li><strong>评估成本收益：</strong> 明确引入微前端要解决的具体问题，评估带来的复杂度增加是否值得。</li></ul><h2 id="who-谁来负责-参与" tabindex="-1">Who(谁来负责/参与？) <a class="header-anchor" href="#who-谁来负责-参与" aria-label="Permalink to &quot;Who(谁来负责/参与？)&quot;">​</a></h2><ul><li><p><strong>架构师/技术负责人：</strong></p><ul><li>设计整体架构（集成方式、通信机制、路由方案、共享策略）。</li><li>制定技术规范和标准（如微应用接口、通信协议）。</li><li>选择合适的技术方案和工具链。</li></ul></li><li><p><strong>开发团队：</strong></p><ul><li><strong>基座/容器团队：</strong> 负责开发维护主应用，提供核心服务（路由、加载、通信总线、共享库管理）。</li><li><strong>微应用团队：</strong> 独立负责各自微应用的开发、测试、构建、部署（端到端职责）。</li><li>遵守约定的接口和规范，确保集成兼容性。</li></ul></li><li><p><strong>运维/平台团队：</strong></p><ul><li>搭建支持独立部署的 CI/CD 流水线。</li><li>提供微应用注册、发现、监控的平台或基础设施。</li><li>管理共享依赖的部署和版本控制。</li></ul></li><li><p><strong>测试团队：</strong></p><ul><li>制定集成测试策略（微应用间、微应用与基座间）。</li><li>进行端到端测试，确保整体用户体验一致。</li><li>支持微应用的独立测试。</li></ul></li></ul><h2 id="how-如何实现微前端" tabindex="-1">How（如何实现微前端？） <a class="header-anchor" href="#how-如何实现微前端" aria-label="Permalink to &quot;How（如何实现微前端？）&quot;">​</a></h2><h3 id="iframe-方案" tabindex="-1">iframe 方案 <a class="header-anchor" href="#iframe-方案" aria-label="Permalink to &quot;iframe 方案&quot;">​</a></h3><p>在正常的项目开发中，如果一个项目中嵌入另外一个项目的页面，普遍的思路都是 iframe，而且 iframe 本身具有天然的隔离特性，不需要考虑各个项目之间 css、js 的冲突问题，但是正因为它的隔离性无法突破，从而导致应用之间上下文无法被共享，造成开发、产品体验的问题：</p><ul><li>URL 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用；</li><li>UI 不同步，DOM 结构不共享，iframe 内部弹窗浮层不能展示在页面中心、遮罩只能遮住 iframe；</li><li>全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。iframe 内部错误也无法监控</li><li>页面加载速度慢；每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程</li></ul><h3 id="基于-nginx-路由分发" tabindex="-1">基于 Nginx 路由分发 <a class="header-anchor" href="#基于-nginx-路由分发" aria-label="Permalink to &quot;基于 Nginx 路由分发&quot;">​</a></h3><p>方案：通过路由将不同的业务分发到不同的、独立的前端应用上。通常使用 <strong>HTTP 服务器的反向代理</strong>来实现。</p><p>例如www.abc.com/app1对应app1，www.abc.com/app2对应app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置，当然这么做优点十分明显了，简单，快速，易配置。缺点其实也和iframe差不多，iframe有的缺点他都有，比如在切换应用时触发发页面刷新，项目之间通信不易</p><h3 id="基于-npm-的集成" tabindex="-1">基于 NPM 的集成 <a class="header-anchor" href="#基于-npm-的集成" aria-label="Permalink to &quot;基于 NPM 的集成&quot;">​</a></h3><p>将子应用封装成 npm 包，通过组件的方式引入，在性能和兼容性上是最优的方案，但却有一个致命的问题就是版本更新，每次版本发布需要通知接入方同步更新，管理非常困难。而且也不可能成为一种长期维护的架构选择，随着时间的推移，系统越来越臃肿，不同 npm 之间的管理会越来越困难，特别是如果还有关键人员的变动的话。</p><h3 id="基于-webpack5-的-模块联邦技术" tabindex="-1">基于 webpack5 的 模块联邦技术 <a class="header-anchor" href="#基于-webpack5-的-模块联邦技术" aria-label="Permalink to &quot;基于 webpack5 的 模块联邦技术&quot;">​</a></h3><p>webpack 提出 Module Federation，模块联邦技术，这个技术允许在多个 webpack 编译产物之间共享模块、依赖、页面甚至应用。每个构建都充当一个容器，也可将其他构建作为容器。通过这种方式，每个构建都能够通过从对应容器中加载模块来访问其他容器暴露出来的模块。简单来说就是:<strong>可以使用别人共享的模块，自己也可以共享模块给别人，这样可以真正的让项目达到微模块的级别</strong>。不过模块联邦缺陷也非常明显，并不是现在主流的微前端框架，一是对 webpack5 强依赖，老旧项目不友好，二是也没有有效的 css 沙箱和 js 沙箱，需要靠用户自觉</p><h3 id="微前端框架" tabindex="-1">微前端框架 <a class="header-anchor" href="#微前端框架" aria-label="Permalink to &quot;微前端框架&quot;">​</a></h3><h4 id="single-spa" tabindex="-1">single-spa <a class="header-anchor" href="#single-spa" aria-label="Permalink to &quot;single-spa&quot;">​</a></h4><p>2018 年，第一个微前端工具 single-spa 在 github 上开源，single-spa 是一个用于前端微服务化的 JavaScript 前端解决方案。single-spa 的核心就是定义了一套协议。协议包含主应用的配置信息和子应用的生命周期，通过这套协议，主应用可以方便的知道在什么情况下激活哪个子应用。简单来说：<strong>子应用之间完全独立，互不依赖。统一由基座工程(主应用)进行管理，按照 DOM 节点的注册、挂载、卸载来完成。</strong></p><p>当前流行的大量框架都是 single-spa 的上层封装，但是如果作为生产选型，single-spa 提供的是较为基础的 api，应用在实际项目中需要进行大量封装且入侵性强，使用起来不太方便。</p><h4 id="目前市面上常见的微前端框架" tabindex="-1">目前市面上常见的微前端框架 <a class="header-anchor" href="#目前市面上常见的微前端框架" aria-label="Permalink to &quot;目前市面上常见的微前端框架&quot;">​</a></h4><ul><li>阿里的 qiankun</li><li>京东的 Micro-app</li><li>腾讯的无界</li></ul><p>具体实现细节虽然各自有差异，但是总体架构基本都是主应用(基座应用)---子应用这种方式</p><h4 id="常见微前端框架基础组成" tabindex="-1">常见微前端框架基础组成 <a class="header-anchor" href="#常见微前端框架基础组成" aria-label="Permalink to &quot;常见微前端框架基础组成&quot;">​</a></h4><p><img src="'+r+'" alt="常见微前端框架基础组成"></p><h4 id="微前端框架需要处理的两个问题" tabindex="-1">微前端框架需要处理的两个问题 <a class="header-anchor" href="#微前端框架需要处理的两个问题" aria-label="Permalink to &quot;微前端框架需要处理的两个问题&quot;">​</a></h4><p>微前端框架都面临两大共性问题，如果已经解决，那就说明基本可用了：</p><ul><li><strong>应用的加载与切换</strong>。包括路由的处理、应用加载的处理和应用入口的选择。</li><li><strong>应用的隔离与通信</strong>。这是应用已经加载之后面临的问题，它们包括 JS 的隔离（也就是副作用的隔离）、样式的隔离、也包括父子应用和子子应用之间的通信问题。</li></ul><p><img src="'+h+`" alt="微前端框架两大共性问题"></p><blockquote><p>解释：简单来说，之前使用 iframe，我们不用考虑太多，直接主应用中，通过 iframe 内嵌子应用就行了。那现在使用的这些微前端框架，在不使用 iframe 的情况下，需要想一种办法，通过主应用加载到子应用，并且把子应用的内容加载到主应用的页面进行显示。而且在实现这些的同时，还不能造成主应用和子应用之间的冲突，也就是所谓的 js 隔离和样式隔离。而且最好还能够实现应用之间的通信，这样就可以弥补使用 iframe 所带来的缺点。</p></blockquote><p>所以如何实现将子应用加载到主应用，并且把子应用的内容加载到主页面进行的显示的呢？那无非就是：</p><ul><li>需要一个地址加载到子应用，也就是所谓的路由</li><li>将 URL 地址读取的子应用内容，渲染加载出来</li></ul><h5 id="加载子应用" tabindex="-1">加载子应用 <a class="header-anchor" href="#加载子应用" aria-label="Permalink to &quot;加载子应用&quot;">​</a></h5><ul><li><ol><li>基于 single-span 实现</li></ol><p>通过注册微应用方式（registerMicroApps），把路由 path 和子应用关联起来，跳转对应路由时，微应用就会被插入到指定的 container（dom）中。同时一次调用微应用暴露出的生命周期钩子。微应用里可以在定义子路由。</p></li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { registerMicroApps, start } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;qiankun&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">registerMicroApps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;app-vue2-demo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//子应用名称，唯一</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    entry: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;//localhost:4001&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//子应用地址</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    container: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#subapp-container&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子应用挂载的div</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    activeRule: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/app-vue2-demo&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //子应用激活规则</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 启动 qiankun</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><img src="`+k+`" alt="微前端框架两大共性问题"></p><ul><li><ol start="2"><li>基于 Web Components</li></ol><p>什么是 Web Components，点击这里去查看？</p><p>先在主应用里自己定义路由，然后在路由组件里使用 Web Components，子应用里可以再定义子路由。</p></li></ul><p>路由配置：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 路由配置</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //路由路径最好是非严格匹配</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/app-vue2-demo*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Vue2DemoPage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;@/views/Vue2DemoPage.vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>对应页面:</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;!--</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      name(必传)：应用名称</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      url(必传)：应用地址</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      baseroute(可选)：基座应用分配给子应用的基础路由</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">micro-app</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;app-vue2-demo&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      url</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://localhost:4001/&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      baseroute</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/app-vue2-demo&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     &gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">micro-app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><img src="`+o+'" alt="基于 Web Componentts的"></p>',59)]))}const q=i(d,[["render",c]]);export{F as __pageData,q as default};
