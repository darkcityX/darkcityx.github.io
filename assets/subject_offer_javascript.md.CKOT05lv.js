import{_ as l,c as t,a0 as e,o as i}from"./chunks/framework.CSihnngI.js";const _=JSON.parse('{"title":"javascript 面试题汇总","description":"","frontmatter":{},"headers":[],"relativePath":"subject/offer/javascript.md","filePath":"subject/offer/javascript.md","lastUpdated":1750953333000}'),r={name:"subject/offer/javascript.md"};function o(s,a,n,c,p,d){return i(),t("div",null,a[0]||(a[0]=[e('<h1 id="javascript-面试题汇总" tabindex="-1">javascript 面试题汇总 <a class="header-anchor" href="#javascript-面试题汇总" aria-label="Permalink to &quot;javascript 面试题汇总&quot;">​</a></h1><h2 id="var、let、const的区别-什么是块级作用域" tabindex="-1">var、let、const的区别？什么是块级作用域？ <a class="header-anchor" href="#var、let、const的区别-什么是块级作用域" aria-label="Permalink to &quot;var、let、const的区别？什么是块级作用域？&quot;">​</a></h2><ul><li>var：定义变量，有变量提升，可以跨块访问，没有块级作用域的概念，不能跨函数访问</li><li>let：es6新增的定义变量的方式，没有变量提升，不可以重复声明，有块级作用域的概念，</li><li>const： es6新增的定义常量的方式，没有变量提升，声明的变量不可修改，有块级作用域的概念。</li></ul><p>最初在js中，只有全局作用域、函数作用域，没有块级作用域的概念，在es6时，新增了块级作用域的概念。块级作用域解决了在for循环中声明变量泄漏成全局变量的问题</p><h2 id="js中的数据类型有哪些-基本类型和引用类型的区别是什么" tabindex="-1">JS中的数据类型有哪些？基本类型和引用类型的区别是什么？ <a class="header-anchor" href="#js中的数据类型有哪些-基本类型和引用类型的区别是什么" aria-label="Permalink to &quot;JS中的数据类型有哪些？基本类型和引用类型的区别是什么？&quot;">​</a></h2><p>JS中的数据类型分为两类：</p><ul><li>简单值（基础类型/原始类型）：简单值分为7中：String字符串类型、Boolean布尔值类型、Number数字类型、undefined、null、symbol符号类型，bigInt大数类型</li><li>复杂值（引用值/引用类型）：复杂值就一种，object，像数组、函数、正则这些统统都是对象类型，函数的本质也是对象，其内部有一个特别的属性[[call]],有了该属性，则标识该对象是可调用的，也区分了普通对象和函数对象，也因此设计使得JS中可以实现高阶函数。</li></ul><p>内存存储分为栈和堆：</p><ul><li>栈内存：栈内存因其数据大小和生命周期的可预测性而易于管理和快速访问。栈支持快速的数据分配和销毁过程</li><li>堆内存：堆内存更加灵活，可以动态的分配和释放空间，适合存储生命周期长活着大小不确定的数据。是用堆内存可以有效地管理大量的数据，但相对于栈来说，其管理成本更高，访问速度也更慢。</li></ul><p>对于简单值而言，其通常存储于栈内存，简单值的存储通常包括直接在栈内存中分配的数据空间，并且直接存储了数据的实际值</p><p>对于复杂值而言，具体的值是存储在堆内存离的，因为复杂值往往大小不固定，无法在栈区分配一个固定大小的内存，因此具体的数据放在堆里面，而栈区存储一个内存地址，通过该内存地址可以访问到堆区里面具体的数据。</p><p><strong>JS中在调用函数时，通通都是值传递，而非引用传递</strong></p><ul><li><ol><li>访问方式：简单值是按值访问，也就是说，一个变量如果存储的是一个简单值，当访问这个变量的时候，得到的是对应值；复杂值虽然也是按值访问，但是由于值对应的是一个内存地址，不需要进一步获取地址值后对应的值。</li></ol></li><li><ol start="2"><li>比较方式：无论简单值还是复杂值，都是进行值的比较，不过由于复杂值对应的值是一个内存地址，因此，只有这个内存地址相同时，才会被认为是相等的。</li></ol></li><li><ol start="3"><li>动态属性： 对于复制值来说，可以动态的为其添加属性和方法，这一点是简单值做不到的，如果为简单值动态添加属性，不会报错，会静默失败，访问时返回的值为undefined，如果为简单值添加方法，则会报错</li></ol></li><li><ol start="4"><li>变量赋值：复杂值和简单值都是讲值复制一份然后赋值给另一个变量，不过由于复杂值复制的是内存地址，因此修改新的变量会对旧的有影响。</li></ol></li></ul>',13)]))}const f=l(r,[["render",o]]);export{_ as __pageData,f as default};
