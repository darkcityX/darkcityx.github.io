import{_ as e,c as i,a0 as n,o as l}from"./chunks/framework.CSihnngI.js";const s=JSON.parse('{"title":"落地qiankun","description":"","frontmatter":{},"headers":[],"relativePath":"article/microFrontend/qiankun.md","filePath":"article/microFrontend/qiankun.md","lastUpdated":1751377007000}'),r={name:"article/microFrontend/qiankun.md"};function t(o,a,u,p,k,h){return l(),i("div",null,a[0]||(a[0]=[n('<h1 id="落地qiankun" tabindex="-1">落地qiankun <a class="header-anchor" href="#落地qiankun" aria-label="Permalink to &quot;落地qiankun&quot;">​</a></h1><h2 id="项目背景" tabindex="-1">项目背景 <a class="header-anchor" href="#项目背景" aria-label="Permalink to &quot;项目背景&quot;">​</a></h2><ul><li><strong>旧项目市场竞争力落后</strong>：项目是公司几年的B端项目，一直在维护，不过维护的成本越来越高，很多地方，不论是客户也好，还是公司内部的人都比较不满意。后台的代码量也越来来臃肿。所以公司当时新成立了一个部门对该项目做标品化的产品，后续用来抢占的该类型产品的市场。</li><li><strong>技术栈落后，</strong>：因为当时该项目的还在维护，所以，公司要求需要对该项目中的部分模块可以最小化影响的平移，并且需要支持后续新开发功能模块可以使用时下最新的热门技术栈。</li><li><strong>公司要求</strong>：作为一个B端项目来说，各个功能业务边界比较明确，虽然项目体量庞大，但是业务之间耦合度不算太高。也因为项目持续年限较久，业务的技术栈比较老旧，面临扩展困难，ui陈旧，第三方库也不敢轻易更换或升级，应公司要求，也到了不得不做的地步。</li></ul><h2 id="为什么选择微前端" tabindex="-1">为什么选择微前端 <a class="header-anchor" href="#为什么选择微前端" aria-label="Permalink to &quot;为什么选择微前端&quot;">​</a></h2><p>在刚开始技术调研的时候，也并不是直接使用市面上的微前端框架方案，而是打算使用iframe，但是和旧项目团队成员沟通以及考虑到业务中的需要和后续的升级问题，还是排除了这个方案。</p><h2 id="对于市面上常用的微前端库-为什么选择qiankun" tabindex="-1">对于市面上常用的微前端库，为什么选择qiankun？ <a class="header-anchor" href="#对于市面上常用的微前端库-为什么选择qiankun" aria-label="Permalink to &quot;对于市面上常用的微前端库，为什么选择qiankun？&quot;">​</a></h2><p>市面上常用的微前端库，当时开源出来的就只有sigle-spa、qiankun。由于sigle-spa这个框架本身设计是更加面向底层的，且在使用时过于原始，所以就选择了当时qiankun，而且qiankun当时也是基于sigle-spa进行封装的上层应用框架，使用更加简洁，社区对比也更加活跃，且有官方人员专门支持，所以就选择了qiankun。</p><p>因为选择比较少，所以在横向对比了iframe、qiankun等方案后，还是选择了qiankun。在使用过程中，也确实遇到了很多问题，不过通过对qiankun原理掌握的比较清楚后，这些问题也得到了解决。</p><p>经过微前端的查分，在开发侧，基本做到了子项目的独立开发，独立发布，当然了，需要通过主应用联调的内容刚刚开始还存在一些问题，不过在子项目业务，以及范围完全理清后，也非常顺畅了。</p><h2 id="子应用拆分按什么规则拆分的" tabindex="-1">子应用拆分按什么规则拆分的 <a class="header-anchor" href="#子应用拆分按什么规则拆分的" aria-label="Permalink to &quot;子应用拆分按什么规则拆分的&quot;">​</a></h2><p>子应用拆分首要考虑的是按照业务进行拆分。其中有很多细节要在选择的时候需要考虑。总的来说我们定下了几个标准：</p><ul><li>保证核心业务的独立性，将无关的子业务拆分解耦</li><li>业务关联紧密的功能单元应用做成一个子应用，反之关联不紧密的可以考虑拆分成多个微应用，判断业务关联是否紧密的标准，其实很简单，就是看是否通信频繁。</li><li>其次还要看页面结构，如果结构不清晰，业务有交叉，就算是单独的业务，也会做成一个子应用。</li><li>还要考虑度的问题，一开始不用拆分的太细，因为流程已经很清晰了，所以如果有有拆分需求，在进行拆分也是可以的</li></ul><h2 id="qiankun的原理问题" tabindex="-1">qiankun的原理问题 <a class="header-anchor" href="#qiankun的原理问题" aria-label="Permalink to &quot;qiankun的原理问题&quot;">​</a></h2><h3 id="qiankun支持vite吗" tabindex="-1">qiankun支持vite吗？ <a class="header-anchor" href="#qiankun支持vite吗" aria-label="Permalink to &quot;qiankun支持vite吗？&quot;">​</a></h3><p>不支持，因为qiankun是HTML Entry的机制，说白了，就是利用webpack打包的机制，将子应用的HTML内容直接读取到主应用中来，再进行处理。而vite本身是ES Module的，也就是说 vite 构建的 js 内容必须在 type=module 的 script 里面，这会导致qiankun其实拿不到子应用JS里面的内容执行。</p><p>虽然市面上有一些基于qiankun子应用可以使用vite的插件，但是我们并不建议使用，一是这样做有很大的隐患，肯定需要修改很多内容。二是我们的项目本身就是做拆分，因此在打包工具上做了统一。</p><p>虽然微前端不限制技术手段，但是规范化不做统一处理，那么我们的项目只会从一个问题，变成另外一个更大的问题</p><h3 id="qiankun支持keep-alive吗-如果不支持-有没有自己实现的思路" tabindex="-1">qiankun支持keep-alive吗，如果不支持，有没有自己实现的思路？ <a class="header-anchor" href="#qiankun支持keep-alive吗-如果不支持-有没有自己实现的思路" aria-label="Permalink to &quot;qiankun支持keep-alive吗，如果不支持，有没有自己实现的思路？&quot;">​</a></h3><p>qiankun支持keep-alive吗，如果不支持，有没有自己实现的思路？</p><p>在 qiankun 中，实现 keep-alive 的需求有一定的挑战性。这是因为 qiankun 的设计理念是在子应用卸载时，将环境还原到子应用加载前的状态，以防止子应用对全局环境造成污染。这种设计理念与 keep-alive 的需求是相悖的，因为 keep-alive 需要保留子应用的状态，而不是在子应用卸载时将其状态清除</p><p>我们当时也出现了这种需求，我说一下我们的处理办法：</p><p>qiankun中还提供了手动加载函数loadMicroApp，我们可以获取当前激活子应用的对象。所以，我们要实现keep-alive,就需要借助这个函数</p><p>另外，我们要实现keep-alive实际上，我们只需要缓存子应用的具体页面就行，而子应用如果是vue的项目，是可以有自己的keep-alive对当前路由进行缓存的。所以，要实现keep-alive效果，我们就需要两步：</p><ul><li>1、缓存子应用对象</li><li>2、子应用自身实现keep-alive效果</li></ul><h3 id="微前端打包发布问题" tabindex="-1">微前端打包发布问题 <a class="header-anchor" href="#微前端打包发布问题" aria-label="Permalink to &quot;微前端打包发布问题&quot;">​</a></h3><h3 id="公共依赖" tabindex="-1">公共依赖 <a class="header-anchor" href="#公共依赖" aria-label="Permalink to &quot;公共依赖&quot;">​</a></h3><p>如果主子应用使用的是相同的库或者包，微前端怎么解决重复加载导致资源浪费的问题？</p><p>虽然共享依赖并不建议，但如果你真的有这个需求，你可以在微应用中将公共依赖配置成 externals，然后在主应用中导入这些公共依赖。</p><p>（当然如果面试官要追问：具体怎么操作Externals，你简单介绍一下Externals的原理就行了）</p><p>无非就是qiankun 将子项目的外链 script 标签，内容请求到之后，会记录到一个全局变量中，下次再次使用，他会先从这个全局变量中取。这样就会实现内容的复用，只要保证两个链接的 url 一致即可。</p><p>为了节约那么一点打包空间，个人非常不建议这么做，这样子应用不能很方便的独立运行，这和微前端的理念是违背冲突的，另外由于关键对象都挂载到了window上，很容易引起子应用和主应用之间的冲突</p><h2 id="具体实现" tabindex="-1">具体实现 <a class="header-anchor" href="#具体实现" aria-label="Permalink to &quot;具体实现&quot;">​</a></h2><h2 id="后续开源的微前端框架都有哪些-有了解过吗" tabindex="-1">后续开源的微前端框架都有哪些？有了解过吗？ <a class="header-anchor" href="#后续开源的微前端框架都有哪些-有了解过吗" aria-label="Permalink to &quot;后续开源的微前端框架都有哪些？有了解过吗？&quot;">​</a></h2><h2 id="市面上微前端库的优缺点" tabindex="-1">市面上微前端库的优缺点？ <a class="header-anchor" href="#市面上微前端库的优缺点" aria-label="Permalink to &quot;市面上微前端库的优缺点？&quot;">​</a></h2>',34)]))}const d=e(r,[["render",t]]);export{s as __pageData,d as default};
